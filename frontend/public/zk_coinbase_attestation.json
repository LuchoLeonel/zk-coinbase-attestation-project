{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":16790212093651423636,"abi":{"parameters":[{"name":"attester_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"attester_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"attester_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_attestation_tx","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"expected_attester","type":{"kind":"field"},"visibility":"public"},{"name":"user_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"user_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"user_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"nonce_hash","type":{"kind":"field"},"visibility":"public"},{"name":"timestamp_hash","type":{"kind":"field"},"visibility":"public"},{"name":"tx_calldata","type":{"kind":"array","length":36,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2dC9wf15jH/8mb0CAIgiAIgiDMmfsgS9laXYqiKIq5UpQtii5F2aKo+2Xd7/d1v9/vd7s2CIIgCIIgS9gga7/P2zfM/E2q6f83r3k/7ewenZy8Oe85c87zPL/f7zlzZtnk7OvpR0wmj1t59v0yytzCf+06YqpuWU/d8p66uZ66FT11K3vqLtRTd+GeuiN66lb11F2kp+6iPXUX66lb3VN38Z66S/TUXbKnbk1P3aV66i7dU3eZnrq1PXWX7am7XE/d5Xvq1vXUXaGn7oo9dVfqqVvfU3flnrqr9NRdtaduQ0/d1Xrqrt5Td42euo09ddfsqbtWT921e+o29dRdp6fuuj111+up29xTd/2euhv01Hk9da6nzu+pC3rqwp66qKcu7qlLeurSnrqsp+6GPXU36qm7cU/dlp66f+ipu0lP3U176o7sqbtZT93Ne+r+safuqJ66W/TU/VNP3S176o7uqfvnnrpb9dTduqfumJ662/TU3ban7nY9dcf21N2+p+4OPXV37Kk7rqfuTj11d+6pu0tP3fE9dXftqbtbT93de+pO6Km7R0/dPXvq7tVTl/fUFT11ZU9d1VNX99Q1PXX37qm7T0/diT119+2pu19P3f176k7qqXtAT90De+r+pafu5J66B/XUPbin7iE9daf01D20p+5hPXUP76k7tafuX3vqHtFT98ieutN66h7VU/fonrrH9NSd3lP32J66x/XU/VtP3Rk9dY/vqXtCT90Te+rO7Kl7Uk/dk3vqntJTd1ZP3VN76p7WU/f0nrpn9NQ9s6fuWT11z+6pe05P3XN76p7XU/fvPXXP76l7QU/dC3vqXtRT9+Keupf01L20p+7lPXWv6Kl7ZU/dq3rqXt1T95qeutf21L2up+71PXVv6Kl7Y0/df/TUvamn7s09dW/pqXtrT93beure3lP3jp66d/bUvaun7t09de/pqXtvT937eure31P3gZ66D/bUfain7sM9dR/pqftoT93Heuo+3lP3iZ66T/bUfaqn7tM9dZ/pqftsT93neuo+31P3hZ66L/bU/WdP3X/11H2pp+6/e+q29tR9uafuKz11X+2p29ZT97Weuq/31H2jp257T903e+q+1VP37Z66HT113+mp+25P3fd66nb21H2/p+4HPXU/7Knb1VP3o566H/fU/aSnbndP3U976n7WU/fznro9PXW/6Kn7ZU/dr3rq9vbU/U9P3a976n7TU7evp+63PXW/66n73566/T11v++p+0NP3R976g701P1fT92feursf6brlvXULe+pm+upW9FTt7Kn7kI9dRfuqTuip25VT91Feuou2lN3sZ661T11F++pu0RP3SV76tb01F2qp+7SPXWX6alb21N32Z66y/XUXb6nbl1P3RV66q7YU3elnrr1PXVX7qm7Sk/dVXvqrtVTd+2euk09ddfpqbtuT931euo299Rdv6fuBj11Xk+d66nze+qCnrqwpy7qqYt76pKeurSnLuupu2FP3Y166m7cU7elp+4feupu0lN30566I3vqbtZTd/Oeun/sqTuqp+4WrboLLfzXroN1y1r30/mOg/ft/EY7r9HOZ7TzGEe07tt5i3a+op2naOcn2nmJdj6inYdo5x/aeYd2vqGdZ2jnF9p5hXY+oZ1HaOcP2nmDdr6gnSdo5wfaeYF2PqCdB7hq635D676t91+9dd/W99u6flvPb+v4127dt3X7tl7f1unb+nxbl2/r8W0dvq2/t3X3tt7e1tnb+npbV2/r6W0dva2ft3Xztl7e1snb+nhbF2/r4W0d/Kat+yNb9229++at+7a+3da123p2W8e+Zeu+rVu39eq2Tt3Wp9u6dFuPbuvQbf25rTu39ea2ztzWl9u6cltPbuvIbf24rRu39eK2TtzWh9u6cFsPbuvA92rd5637tt5btu7b+m5b123ruW0d9z6t+7Zu29Zr2zptW59t67JtPbatw7b117bu2tZb2zprW19t66ptPbWto7b107Zu2tZL2zppWx9t66JtPbStgz6mdX96676tdz6udd/WN9u6ZlvPbOuYT2zdt3XLtl7Z1inb+mRbl2zrkW0dsq0/tnXHtt7Y1hnb+mJbV2zriW0dsa0ftnXDtl7Y1gnb+mBbF2zrgQd1wH+yP7Sug3+86cJ/vdkuZ+0fbCvw4jCsE792gcs9PyvSyAujIk5d6qI0qvw0COo0TJOsyBIvc2FQuybKgmahsRUL7Syf/PV1hLjfsrac5y3TtOXsf5Yr2nJn/2du9rbcwZsVs7bl/nK7cra2XPsPF5qlLdf944V168ub9FznsW03XdG2j1suGPTR9l8rB4G4/cWHp+qObhnrwesis3Xurzora+sCwzrMlpaGYR1mkPCmgoS7pTDgtO3B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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\n#[deprecated(\"keccak256 is being deprecated from the stdlib, use https://github.com/noir-lang/keccak256 instead\")]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"mod utils;\nuse utils::{concat_nonce_and_timestamp, concat_prefix_and_digest, extract_address_from_calldata};\nuse dep::ecrecover::ecrecover;\nuse dep::keccak256::keccak256;\nuse std::hash::poseidon;\n\n\nglobal HARDCODED_SELECTOR: [u8; 4] = [86, 254, 237, 94];\nglobal ETH_PREFIX_BYTES: [u8; 28] = [\n    25, 69, 116, 104, 101, 114, 101, 117,\n    109, 32, 83, 105, 103, 110, 101, 100,\n    32, 77, 101, 115, 115, 97, 103, 101,\n    58, 10, 51, 50\n];\n\n\n// This is the main circuit logic for verifying a Coinbase-style ZK attestation.\n// It checks that both the attester (e.g., Coinbase) and the user have signed expected messages using ECDSA.\nfn main(\n    attester_pub_key_x: [u8; 32],\n    attester_pub_key_y: [u8; 32],\n    attester_signature: [u8; 64],\n    hashed_attestation_tx: pub [u8; 32],\n    expected_attester: pub Field,\n    user_pub_key_x: [u8; 32],\n    user_pub_key_y: [u8; 32],\n    user_signature: [u8; 64],\n    nonce_hash: pub Field,\n    timestamp_hash: pub Field,\n    tx_calldata: [u8; 36],\n) {\n    // Recover the Ethereum address from the attester's public key and signature over the attestation hash.\n    // This proves that the attestation was genuinely signed by the trusted attester (e.g., Coinbase).\n    let attester_addr = ecrecover(\n        attester_pub_key_x,\n        attester_pub_key_y,\n        attester_signature,\n        hashed_attestation_tx,\n    );\n    // Ensure the recovered attester address matches the expected one provided publicly.\n    // This prevents malicious signatures from unauthorized attesters.\n    assert(attester_addr == expected_attester);\n\n\n    // Generate a unique hash from the nonce and timestamp to ensure freshness.\n    // This prevents replay attacks by making each signature unique and tied to a specific session.\n    // The hash is prefixed following Ethereum's personal_sign format, then hashed again to produce the final signed message.\n    \n    \n    let combined_hash = poseidon::bn254::hash_2([nonce_hash, timestamp_hash]);\n\n    let message = concat_prefix_and_digest(ETH_PREFIX_BYTES, combined_hash.to_be_bytes());\n    let signed_user_hash = keccak256(message, 60);\n\n    // Recover the user's Ethereum address from their public key and signature over their identity hash.\n    // This shows that the user claims ownership of a particular address (e.g., for KYC or eligibility proofs).\n    let user_addr = ecrecover(\n        user_pub_key_x,\n        user_pub_key_y,\n        user_signature,\n        signed_user_hash,\n    );\n\n    // Compare the selector to the expected function selector bytes\n    for i in 0..4 {\n        assert(tx_calldata[i] == HARDCODED_SELECTOR[i]);\n    }\n\n    // Extract the user address from the calldata (last 20 bytes)\n    let extracted_addr = extract_address_from_calldata(tx_calldata);\n\n    // Ensure the recovered user address matches the expected address.\n    // This binds the user's signature to their identity in the attestation process.\n    assert(user_addr == extracted_addr);\n}","path":"/home/lucholeonel/CODE-werify/zero-knowledge/zk-coinbase-attestation-project/frontend/circuit/src/main.nr"},"63":{"source":"mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/lucholeonel/nargo/github.com/colinnielsen/ecrecover-noir/v0.30.0/src/lib.nr"},"64":{"source":"use dep::std;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/lucholeonel/nargo/github.com/colinnielsen/ecrecover-noir/v0.30.0/src/secp256k1.nr"},"67":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/home/lucholeonel/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}