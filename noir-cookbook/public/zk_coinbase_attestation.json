{
  "noir_version": "1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767",
  "hash": 10686712474691328122,
  "abi": {
    "parameters": [
      {
        "name": "attester_pub_key_x",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "attester_pub_key_y",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "attester_signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "hashed_attestation_tx",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "expected_attester",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "user_pub_key_x",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "user_pub_key_y",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "user_signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "nonce_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "timestamp_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "tx_calldata",
        "type": {
          "kind": "array",
          "length": 36,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "25": {
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "26": {
      "source": "use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n",
      "path": "std/hash/keccak.nr"
    },
    "27": {
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "69": {
      "source": "mod utils;\nuse dep::ecrecover::ecrecover;\nuse dep::keccak256::keccak256;\nuse utils::{concat_nonce_and_timestamp, concat_prefix_and_digest, extract_address_from_calldata};\n\nglobal HARDCODED_SELECTOR: [u8; 4] = [86, 254, 237, 94];\nglobal ETH_PREFIX_BYTES: [u8; 28] = [\n    25, 69, 116, 104, 101, 114, 101, 117, 109, 32, 83, 105, 103, 110, 101, 100, 32, 77, 101, 115,\n    115, 97, 103, 101, 58, 10, 51, 50,\n];\n\n// This is the main circuit logic for verifying a Coinbase-style ZK attestation.\n// It checks that both the attester (e.g., Coinbase) and the user have signed expected messages using ECDSA.\nfn main(\n    attester_pub_key_x: [u8; 32],\n    attester_pub_key_y: [u8; 32],\n    attester_signature: [u8; 64],\n    hashed_attestation_tx: pub [u8; 32],\n    expected_attester: pub Field,\n    user_pub_key_x: [u8; 32],\n    user_pub_key_y: [u8; 32],\n    user_signature: [u8; 64],\n    nonce_hash: pub [u8; 32],\n    timestamp_hash: pub [u8; 32],\n    tx_calldata: [u8; 36],\n) {\n    // Recover the Ethereum address from the attester's public key and signature over the attestation hash.\n    // This proves that the attestation was genuinely signed by the trusted attester (e.g., Coinbase).\n    let attester_addr = ecrecover(\n        attester_pub_key_x,\n        attester_pub_key_y,\n        attester_signature,\n        hashed_attestation_tx,\n    );\n    // Ensure the recovered attester address matches the expected one provided publicly.\n    // This prevents malicious signatures from unauthorized attesters.\n    assert(attester_addr == expected_attester);\n\n    // Generate a unique hash from the nonce and timestamp to ensure freshness.\n    // This prevents replay attacks by making each signature unique and tied to a specific session.\n    // The hash is prefixed following Ethereum's personal_sign format, then hashed again to produce the final signed message.\n    let pre_digest = concat_nonce_and_timestamp(nonce_hash, timestamp_hash);\n    let digest = keccak256(pre_digest, 64);\n\n    let message = concat_prefix_and_digest(ETH_PREFIX_BYTES, digest);\n    let signed_user_hash = keccak256(message, 60);\n\n    // Recover the user's Ethereum address from their public key and signature over their identity hash.\n    // This shows that the user claims ownership of a particular address (e.g., for KYC or eligibility proofs).\n    let user_addr = ecrecover(\n        user_pub_key_x,\n        user_pub_key_y,\n        user_signature,\n        signed_user_hash,\n    );\n\n    // Compare the selector to the expected function selector bytes\n    for i in 0..4 {\n        assert(tx_calldata[i] == HARDCODED_SELECTOR[i]);\n    }\n\n    // Extract the user address from the calldata (last 20 bytes)\n    let extracted_addr = extract_address_from_calldata(tx_calldata);\n\n    // Ensure the recovered user address matches the expected address.\n    // This binds the user's signature to their identity in the attestation process.\n    assert(user_addr == extracted_addr);\n}\n",
      "path": "/Users/fabiandiaz/personal-repos/zk-coinbase-attestation-project/backend/circuit/src/main.nr"
    },
    "70": {
      "source": "mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/fabiandiaz/nargo/github.com/colinnielsen/ecrecover-noirv0.30.0/src/lib.nr"
    },
    "71": {
      "source": "use dep::std;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/fabiandiaz/nargo/github.com/colinnielsen/ecrecover-noirv0.30.0/src/secp256k1.nr"
    },
    "75": {
      "source": "mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n",
      "path": "/Users/fabiandiaz/nargo/github.com/noir-lang/keccak256v0.1.0/src/keccak256.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert",
    "directive_to_radix"
  ]
}
